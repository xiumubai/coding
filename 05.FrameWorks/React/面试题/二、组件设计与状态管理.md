## 二、组件设计与状态管理

### 1. 如何设计一个高复用性的React组件？请分享你的组件设计经验和最佳实践。

**问题解析**：这个问题考察候选人的组件设计能力和实际经验，关注点是组件的可复用性、可维护性和可扩展性。

**参考答案**：

**高复用性组件设计原则**：

1. **单一职责**：每个组件只做一件事，功能单一

2. **组合优于继承**：使用组合模式构建复杂UI，而非继承

3. **Props设计**：
   - 提供合理默认值
   - 使用PropTypes或TypeScript进行类型检查
   - 设计必要的props，避免过度设计

4. **关注点分离**：
   - 展示型组件（负责UI渲染）
   - 容器型组件（负责数据获取和状态管理）

5. **可控与非可控模式**：支持两种使用方式，增加灵活性

**最佳实践**：

1. **使用组合**：
   ```jsx
   // 使用children属性实现组合
   function Card({ title, children }) {
     return (
       <div className="card">
         <div className="card-header">{title}</div>
         <div className="card-body">{children}</div>
       </div>
     );
   }
   ```

2. **使用Render Props模式**：
   ```jsx
   // 通过render prop传递渲染逻辑
   function DataFetcher({ url, render }) {
     const [data, setData] = useState(null);
     useEffect(() => {
       fetch(url).then(res => res.json()).then(setData);
     }, [url]);
     return render(data);
   }
   ```

3. **使用自定义Hooks抽取逻辑**：
   ```jsx
   // 抽取表单逻辑到自定义Hook
   function useForm(initialValues) {
     const [values, setValues] = useState(initialValues);
     const handleChange = (e) => {
       setValues({ ...values, [e.target.name]: e.target.value });
     };
     return { values, handleChange };
   }
   ```

4. **使用Context API共享数据**：
   ```jsx
   // 创建主题Context
   const ThemeContext = React.createContext('light');
   
   function ThemedButton() {
     const theme = useContext(ThemeContext);
     return <button className={theme}>Themed Button</button>;
   }
   ```

5. **组件拆分与组合**：
   ```jsx
   // 将复杂组件拆分为小组件
   function UserProfile({ user }) {
     return (
       <Card>
         <UserAvatar user={user} />
         <UserInfo user={user} />
         <UserStats user={user} />
       </Card>
     );
   }
   ```

实际经验分享：在设计组件库时，应该从用户使用角度出发，提供简洁的API，同时保持足够的灵活性。组件应该是可组合的，遵循一致的设计语言，并有完善的文档和测试。

### 2. React中的状态管理方案有哪些？你如何选择合适的状态管理方案？

**问题解析**：这个问题考察候选人对React生态系统中状态管理方案的了解，以及在实际项目中的技术选型能力。

**参考答案**：

**React状态管理方案**：

1. **组件内部状态**：
   - useState Hook
   - this.state (类组件)

2. **组件间共享状态**：
   - Props传递（自上而下）
   - Context API（避免Props层层传递）
   - 状态提升（将状态提升到最近的共同父组件）

3. **全局状态管理库**：
   - Redux：预测性强，中间件生态丰富
   - MobX：响应式，样板代码少
   - Recoil：Facebook开发的原子化状态管理
   - Zustand：简单轻量的状态管理
   - Jotai：原子化状态管理，类似Recoil但更轻量
   - XState：基于状态机的状态管理

4. **服务端状态管理**：
   - React Query
   - SWR
   - Apollo Client (GraphQL)

**如何选择合适的状态管理方案**：

1. **项目规模和复杂度**：
   - 小型项目：useState + useContext通常足够
   - 中型项目：可考虑Zustand或Jotai等轻量级方案
   - 大型项目：Redux或MobX提供更严格的状态管理

2. **团队熟悉度**：
   - 考虑团队对各方案的熟悉程度
   - 学习曲线和开发效率

3. **状态特性**：
   - 状态是否需要在多个组件间共享
   - 状态更新频率和复杂度
   - 是否需要中间件处理副作用

4. **性能考虑**：
   - 状态变化是否会导致大范围重渲染
   - 是否需要细粒度控制渲染

5. **开发体验**：
   - 调试工具支持
   - 样板代码多少
   - TypeScript支持

6. **特定需求**：
   - 服务端数据缓存：选择React Query或SWR
   - 表单状态：考虑Formik或React Hook Form
   - 复杂状态转换：考虑XState

选择状态管理方案的决策树：

1. 状态只在单个组件中使用？使用useState
2. 状态需要在几个相关组件间共享？使用状态提升或Context
3. 状态是否代表服务器数据？使用React Query或SWR
4. 应用是否有复杂的全局状态？根据团队偏好和项目需求选择Redux、MobX或其他方案

### 3. Redux、Mobx、Context API各有什么优缺点？在大型应用中如何组织状态管理？

**问题解析**：这个问题深入考察候选人对主流状态管理方案的理解，以及在大型应用中的架构设计能力。

**参考答案**：

**Redux优缺点**：

优点：
- 可预测性强，单向数据流
- 强大的中间件生态系统
- 优秀的开发工具支持
- 时间旅行调试能力
- 社区大，资源丰富

缺点：
- 样板代码较多
- 学习曲线陡峭
- 异步操作处理相对复杂
- 小项目可能过于重量级

**MobX优缺点**：

优点：
- 响应式编程，自动追踪依赖
- 样板代码少，上手快
- 更接近OOP思想，对传统开发者友好
- 灵活性高，约束少

缺点：
- 可预测性不如Redux
- 调试相对困难
- 过度灵活可能导致代码不一致
- 社区相对较小

**Context API优缺点**：

优点：
- React原生支持，无需第三方依赖
- 简单直观，易于理解
- 适合中小型应用
- 与Hooks结合使用效果好

缺点：
- 性能问题：Context变化会导致所有消费组件重新渲染
- 不适合频繁更新的状态
- 缺乏中间件和副作用处理机制
- 状态分割和组合不如专业状态管理库灵活

**大型应用中的状态管理组织**：

1. **状态分层**：
   - UI状态：组件内部useState管理
   - 页面状态：Context API或轻量级状态库
   - 应用状态：Redux/MobX等全局状态管理
   - 服务端状态：React Query/SWR管理

2. **领域驱动设计(DDD)思想**：
   - 按业务领域划分状态模块
   - 每个领域有自己的状态、reducer和action

3. **Redux最佳实践**：
   - 使用Redux Toolkit简化样板代码
   - 按特性(feature)组织文件结构，而非类型
   - 使用createSlice创建标准化的reducer和action
   - 使用createAsyncThunk处理异步逻辑
   - 使用RTK Query处理API请求

4. **状态规范化**：
   - 扁平化嵌套数据结构
   - 避免数据重复
   - 使用实体ID引用关联数据

5. **性能优化**：
   - 使用选择器(selectors)避免不必要的重新计算
   - 使用记忆化(memoization)减少重渲染
   - 考虑使用不可变数据结构库如Immer

6. **模块化和代码分割**：
   - 按功能模块拆分状态
   - 实现动态加载reducer

7. **中间件策略**：
   - 统一处理副作用
   - 集中处理日志、错误等横切关注点

大型应用中，通常会采用混合策略，不同类型的状态使用不同的管理方式，而不是强制使用单一方案。

### 4. 如何处理React应用中的复杂表单状态？你使用过哪些表单库？

**问题解析**：这个问题考察候选人处理实际业务场景中常见的表单需求的能力，以及对相关工具的了解。

**参考答案**：

**处理复杂表单状态的策略**：

1. **状态组织**：
   - 扁平化表单状态结构
   - 将复杂表单拆分为子表单组件
   - 使用嵌套对象表示层级关系

2. **验证处理**：
   - 客户端验证与服务端验证结合
   - 即时验证与提交验证结合
   - 错误信息的统一管理和展示

3. **性能优化**：
   - 避免整个表单重渲染
   - 使用受控组件与非受控组件结合
   - 延迟验证避免频繁计算

4. **用户体验**：
   - 适当的表单反馈
   - 渐进式表单填写
   - 保存草稿和恢复功能

**常用表单库及其特点**：

1. **Formik**：
   - React表单库的事实标准
   - 处理表单状态、验证、提交
   - 内置常用表单组件
   - 与Yup验证库良好集成

   ```jsx
   import { Formik, Form, Field, ErrorMessage } from 'formik';
   import * as Yup from 'yup';
   
   const SignupSchema = Yup.object().shape({
     email: Yup.string().email('无效邮箱').required('必填'),
     password: Yup.string().min(8, '密码太短').required('必填'),
   });
   
   function SignupForm() {
     return (
       <Formik
         initialValues={{ email: '', password: '' }}
         validationSchema={SignupSchema}
         onSubmit={values => console.log(values)}
       >
         <Form>
           <Field name="email" type="email" />
           <ErrorMessage name="email" />
           
           <Field name="password" type="password" />
           <ErrorMessage name="password" />
           
           <button type="submit">提交</button>
         </Form>
       </Formik>
     );
   }
   ```

2. **React Hook Form**：
   - 性能优秀，几乎零重渲染
   - 基于非受控组件和ref
   - 体积小，API简洁
   - 与多种验证库集成

   ```jsx
   import { useForm } from 'react-hook-form';
   import { yupResolver } from '@hookform/resolvers/yup';
   import * as yup from 'yup';
   
   const schema = yup.object().shape({
     email: yup.string().email().required(),
     password: yup.string().min(8).required(),
   });
   
   function SignupForm() {
     const { register, handleSubmit, formState: { errors } } = useForm({
       resolver: yupResolver(schema)
     });
     
     const onSubmit = data => console.log(data);
     
     return (
       <form onSubmit={handleSubmit(onSubmit)}>
         <input {...register('email')} />
         {errors.email && <p>{errors.email.message}</p>}
         
         <input type="password" {...register('password')} />
         {errors.password && <p>{errors.password.message}</p>}
         
         <button type="submit">提交</button>
       </form>
     );
   }
   ```

3. **Final Form**：
   - 框架无关的表单库
   - 订阅模式，高性能
   - 支持字段级验证
   - 支持异步验证

4. **Ant Design Form**：
   - 与Ant Design组件库集成
   - 丰富的表单控件
   - 内置验证系统
   - 支持动态表单项

5. **自定义Hook方案**：
   ```jsx
   function useForm(initialValues) {
     const [values, setValues] = useState(initialValues);
     const [errors, setErrors] = useState({});
     const [touched, setTouched] = useState({});
     
     const handleChange = (e) => {
       const { name, value } = e.target;
       setValues(prev => ({ ...prev, [name]: value }));
     };
     
     const handleBlur = (e) => {
       const { name } = e.target;
       setTouched(prev => ({ ...prev, [name]: true }));
       // 执行验证逻辑
     };
     
     const validate = () => {
       // 验证逻辑
       return Object.keys(errors).length === 0;
     };
     
     const handleSubmit = (callback) => (e) => {
       e.preventDefault();
       if (validate()) {
         callback(values);
       }
     };
     
     return { values, errors, touched, handleChange, handleBlur, handleSubmit };
   }
   ```

在选择表单库时，需要考虑项目需求复杂度、性能要求、团队熟悉度以及与其他库的集成能力。对于简单表单，自定义Hook可能足够；对于复杂表单，专业表单库能提供更完善的功能。

### 5. 如何实现一个自定义Hook？请举例说明你设计过的有价值的自定义Hook。

**问题解析**：这个问题考察候选人对React Hooks的理解和实际应用能力，以及代码复用和抽象的设计能力。

**参考答案**：

**自定义Hook的实现原则**：

1. 自定义Hook是一个以"use"开头的函数
2. 可以调用其他Hooks
3. 不应包含UI渲染逻辑，只关注逻辑复用
4. 应遵循Hooks的规则（只在顶层调用，只在React函数中调用）

**有价值的自定义Hook示例**：

1. **useLocalStorage** - 持久化状态到localStorage

```jsx
function useLocalStorage(key, initialValue) {
  // 惰性初始化状态
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // 更新localStorage的同时更新状态
  const setValue = value => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// 使用示例
function App() {
  const [name, setName] = useLocalStorage('name', 'Bob');
  return (
    <input
      value={name}
      onChange={e => setName(e.target.value)}
    />
  );
}
```

2. **useAsync** - 处理异步操作状态

```jsx
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);

  // 执行异步函数的函数
  const execute = useCallback(async () => {
    setStatus('pending');
    setValue(null);
    setError(null);
    
    try {
      const response = await asyncFunction();
      setValue(response);
      setStatus('success');
      return response;
    } catch (error) {
      setError(error);
      setStatus('error');
      throw error;
    }
  }, [asyncFunction]);

  // 立即执行
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, value, error };
}

// 使用示例
function UserProfile({ userId }) {
  const { status, value, error } = useAsync(() => fetchUser(userId), true);

  if (status === 'idle' || status === 'pending') {
    return <div>Loading...</div>;
  }

  if (status === 'error') {
    return <div>Error: {error.message}</div>;
  }

  return <div>User: {value.name}</div>;
}
```

3. **useMediaQuery** - 响应式设计Hook

```jsx
function useMediaQuery(query) {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    setMatches(mediaQuery.matches);

    // 监听媒体查询变化
    const handler = (event) => setMatches(event.matches);
    mediaQuery.addEventListener('change', handler);

    return () => mediaQuery.removeEventListener('change', handler);
  }, [query]);

  return matches;
}

// 使用示例
function ResponsiveComponent() {
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  return (
    <div>
      {isMobile ? <MobileView /> : <DesktopView />}
    </div>
  );
}
```

4. **useForm** - 表单处理Hook

```jsx
function useForm(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // 当值变化时重新验证
  useEffect(() => {
    if (isSubmitting) {
      const validationErrors = validate ? validate(values) : {};
      setErrors(validationErrors);
      setIsSubmitting(Object.keys(validationErrors).length === 0);
    }
  }, [values, isSubmitting, validate]);

  // 处理字段变化
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues({ ...values, [name]: value });
  };

  // 处理字段失焦
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched({ ...touched, [name]: true });
    
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
    }
  };

  // 处理表单提交
  const handleSubmit = (onSubmit) => (e) => {
    e.preventDefault();
    setTouched(Object.keys(values).reduce((acc, key) => ({ ...acc, [key]: true }), {}));
    setIsSubmitting(true);
    
    const validationErrors = validate ? validate(values) : {};
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length === 0) {
      onSubmit(values);
    }
  };

  // 重置表单
  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    isSubmitting
  };
}

// 使用示例
function SignupForm() {
  const validate = (values) => {
    const errors = {};
    if (!values.email) errors.email = '邮箱是必填的';
    if (!values.password) errors.password = '密码是必填的';
    return errors;
  };

  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    isSubmitting
  } = useForm({ email: '', password: '' }, validate);

  const onSubmit = (values) => {
    console.log('Form submitted with:', values);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          type="email"
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.email && errors.email && <div>{errors.email}</div>}
      </div>
      
      <div>
        <input
          type="password"
          name="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.password && errors.password && <div>{errors.password}</div>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        提交
      </button>
    </form>
  );
}
```

5. **useDebounce** - 防抖Hook

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 使用示例
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      value={searchTerm}
      onChange={e => setSearchTerm(e.target.value)}
      placeholder="搜索..."
    />
  );
}
```

自定义Hook的价值在于将复杂逻辑封装为可重用的单元，提高代码可维护性和可测试性。好的自定义Hook应该关注点分离、命名清晰、接口简单、错误处理完善，并且有良好的文档说明。
